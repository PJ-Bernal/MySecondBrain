---
note_type: note
tags:
  - web_development
  - javascript
  - typescript
  - functions
mn: "[[12.14 Typescript]]"
kt: theorical
checked: false
---
[[12.14 Typescript|Typescript]]

Without any type annotations, is hard to know how to use and what to expect from a function; even the developer will be force to review the function implementation which is not ideal. 
# Why is important to type annotation the return type of a function
>[!blank-container|float-left-small]
![[Pasted image 20250214123342.png]]

In TS, when a function is meant to perform side effects and all code branches don't have **any** return statement, TS will infer the functions' return type as `void`.

>[!blank-container|float-left-small]
>![[Pasted image 20250214123858.png]]

But in TS, when a branch could return something, but the function implementation doesn't have a return statement directly, the function's return type is a union type of the code branch's type and `undefined`

This r


# Function return types
If the function parameters don't have types, TS will infer the return type as `any`. If they have types, then TS will check the function implementation and then, determine the return type.

```ts
function add (a: number, b: number) {
  if(Math.random() > 0.5)
    return a + b;
}
```

The return type of the function will be number or undefined.

![[Pasted image 20250212110928.png|center|350]]

 This could bring some mistakes and undesired behaviors, like this one. Because result could be undefined, it mark as an error using a method that belongs to the number type.
 
![[Pasted image 20250212111226.png|center|350]]

>[!important]
>This means, for clarity, is always better to type the functions with a **valid** return value. So, possible errors can appear when implementing the function and not when using it. 

## What is a valid return type -  function errors during implementation vs when using the function
If the implementation leads TS to infer several return types, and I don't type all of those, an error could appear. Additionally, is better to detect errors when implementing the function rather than when using it like in the above image (this is a 'late error' when I already implement the function, it could be in other module, and I force the developer to go back to the implementation to understand why is this error happening).

![[Pasted image 20250212111725.png]]

A valid return type should enclose all paths the function is intended to work, in this case, I want the function return a number, but it could return undefined as well. So I could fix this earlier. 
# Annotate a function
For functions, annotate the return and parameter types. Required parameters are written first in TS. The compiler can't always infer the types of the parameters, hence, the compiler implicitly use the any type. 

```ts
function testFunc(score: number, message: string): string
{}
```
# Optional parameters
All parameters are required in TS unless I marked it as optional adding `?`. Optional parameters must appear after the require parameters in the function definition. 

```ts
function testFunc(score: number, message?: string): string
{}
```
# Default parameters
A default parameter (literal or expression) is optional if they appear after all required parameter, meaning the default value will be used only if the caller don't pass a value for that parameter. 

```ts
function testFunc(score: number, message: string = 'this is a default parameter'): string
{}
```

>[!multi-column]
>
![[Pasted image 20250128142045.png|center|350]]
>
>![[Pasted image 20250128142112.png]]

# Rest parameters
Represent an indefinite number of arguments **as an array**, useful to let the function receive any number of arguments without explicitly defining each one. They must be the last parameters a function receives when invoked and in the method signature. 

```ts
function GetBooks (name: string, ...booksIds: number[])
{}

GetBooks('libro uno', 2, 3);
GetBooks('libro dos', 5, 6, 8, 9, 12);
```


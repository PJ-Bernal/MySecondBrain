---
note_type: note
tags:
  - programming
  - c#
  - web_development
  - .net_web_api
  - efc
  - controllers
mn:
  - "[[12 Web Dev]]"
  - "[[13.7 C Sharp]]"
kt: theorical
checked:
---
[[13.9 ASP.NET Core Web API|ASP.NET Core Web API]]
# About the repository pattern
>[!blank-container|float-left-medium]
>![[Pasted image 20250122125938.png]]

An abstraction that reduces complexity and aims to make code, safe for the repository implementation, and is persistence ignorant. 

## Persistence ignorant
This pattern is useful to choose (and not only switching) which persistence technology to use for a specific method on the repository. Thus, for the consumers of the repository, there's no interest about the implementation.
# Implementing the repository pattern
## Creating the repo interface
To implement the pattern, a repository interface is created in the services folder, because the services represents the application's business/domain layer (defines how your application interacts with data).

Remember the interface is a contract, not the implementation, thus, to build it I can simply think of what I need to grand from the db to the api user. 

right click -> class -> interface whose name is `I<project name>Repository`. 

The repository interface is in charge of CRUD actions and talk to the db, therefore, the repository interfaces will use the entity classes. 

## Get data
When getting data, two types are possible,:
- `IEnumarable`:  work with data in memory, when the data is already retrieve from the db, and additional operations are required on the app. 
- `IQueryable`: use to built and execute queries on the database side, to filter, sorting and transform data before return data to the app. The db is responsible for that action. LINQ methods like where, order by, etc. are available. 

![[Pasted image 20250122135238.png]]

Queries should be usually async, so to write async code, wrap the type in `Task<>` and add Async to the methods name.  

Also, the return type of getting a city could be null, mind the `?`
## Creating the repo
Inside of services create a class name `<project name>repository`, that will implement the interface. This class implement data handling, no other place in the code should have that. 

This is the class where persistence logic is implemented, so, some methods can use the db context, other can use a service, or efc (entity classes), etc. This example only the db context, the city info context.

Inject the db context using construction injection.

![[Pasted image 20250122134851.png]]

To **implement** an async method, add the async to the method signature, and await to return. In this case, the code is ordering the cities by name.   ^b82f37

![[Pasted image 20250122135200.png]]

In this other method, see, once I grab the desire city, I can add methods like where to add more filters.

![[Pasted image 20250122135439.png]]

![[Pasted image 20250122135504.png]]


# Register the repo
Once the repo is done, register in program, using scope lifetime, the best for repos. 

![[Pasted image 20250122135601.png]]


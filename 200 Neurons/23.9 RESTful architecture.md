---
note_type: note
tags:
  - programming
  - c#
  - web_development
  - .net_web_api
  - rest
  - about
mn:
  - "[[12 Web Dev]]}"
  - "[[13.7 C Sharp]]"
kt: theorical
checked:
---
[[13.9 ASP.NET Core Web API|ASP.NET Core Web API]]

# About RESTful APIS
Representation State Transfer is not a standard but an architectural style. The key is to understand the client changes state depending on the representation of the resource it accessing. REST doesn't have to use JSON as a response, it can returns XML if needed. 

In simple terms, a RESTful API is a way for two systems to communicate over the internet by sending and receiving data in a structured format (usually JSON or XML).

# About REST constrains
REST is define in five mandatory and one optional constrains; see them as design decisions. 
## Uniform Interface
The API and its consumers share a single technical (but consistent and predictable) interface. Because REST use HTTP, the interface is a combination of:
- Resource-base URLs: each resource is identify by a unique URL - where I can find the resource.
- HTTP methods - how can the consumer interact with the resource. 
- HTTP media types: the representation of the resources, json or xml for example, when making a request to the server, or sending a request to the user. Is defined by the media type in the body. 
#### Example
##### Get method
A GET method doesn't have a payload, but it could have a media type by setting the Accept header; Doing this states that the consumer of the API wants a payload in response back in JSON format. 

This request is REST: it have a resource, a method and a media type. 

![[Pasted image 20250203172738.png]]

##### Post method
The request body (JSON format) is the payload. 

![[Pasted image 20250203173009.png]]

Also the body headers not only contain the Accept, but also the Content-type, sos the API knows how to parse the content by looking at the header.

![[Pasted image 20250203173102.png]]

### Sub-constains
The constrain has 4 sub-constrains.

#### Identification of resources
The resources themselves are conceptually separate from the representations that are return to the client, this means:
- The resource is the abstract entity on the server. It exists independently of how it is represented.
- For example, a "user" resource might have properties like id, name, and email, but these properties are not tied to any specific format (e.g., JSON, XML).
- The same resource can have multiple representations. 


```json
{
    "id": 1,
    "name": "John Doe",
    "email": "john@example.com"
}
```

```xml
<user>
    <id>1</id>
    <name>John Doe</name>
    <email>john@example.com</email>
</user>
```

This is important because:
- Flexibility: the server can provide multiple representations (json, xml, html, etc.) of the same resource depending on the client needs.
- Decoupling: the client and server are decoupled because the client only interacts with the representation of the resource, not the resource itself. This allows the server to change how resources are stored or managed internally without affecting the client.

This example show the powerful of this sub-constrain. Detai 